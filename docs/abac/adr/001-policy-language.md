# ADR-001: ポリシー言語の設計

## ステータス

- **日付**: 2025-08-13
- **状態**: 採用
- **決定者**: プロジェクトチーム

## コンテキスト

ABAC（Attribute-Based Access Control）システムにおいて、ポリシーの記述方法は権限制御の中核となる重要な設計決定です。学習用実装として、どのようなポリシー言語を採用するかが、理解の容易さと実装の複雑さのバランスを決定します。

### ABAC における ポリシー言語の重要性

ポリシー言語は、属性の動的評価ルールを定義する手段であり、以下の役割を担います：

- **属性間の関係性の表現**: Subject、Resource、Environment 属性の比較・評価
- **複合条件の記述**: 複数の条件の論理的な組み合わせ
- **動的評価ロジックの実装**: 実行時の文脈に応じた判定処理

### 学習用実装における考慮事項

- **理解しやすさ**: 権限管理の概念学習が主目的
- **デバッグの容易さ**: 学習過程でのステップ実行・デバッグが重要
- **型安全性**: 学習者の実装ミスを早期に発見
- **拡張性**: 段階的な学習に対応した発展性

## 検討したオプション

### オプション1: 独自DSL（Domain Specific Language）

```typescript
// 文字列ベースのDSL例
"user.department == resource.department AND user.level >= 3"
```

**利点:**
- 表現力が高い
- コンパクトな記述が可能
- 非プログラマーでも理解しやすい

**欠点:**
- パーサーの実装が必要
- 型安全性がない
- IDEサポートが限定的
- デバッグが困難
- 実行時エラーのリスク

### オプション2: JSON構造

```typescript
// JSON構造による条件記述例
{
  type: 'and',
  conditions: [
    { type: 'equals', left: 'user.department', right: 'resource.department' },
    { type: 'gte', left: 'user.level', value: 3 }
  ]
}
```

**利点:**
- 構造化された記述
- 拡張性が高い
- パーサーが不要
- 外部化が容易

**欠点:**
- 冗長になりやすい
- ネストが深くなる
- 型安全性の確保が困難
- 複雑な条件の記述が困難

### オプション3: 関数ベース（TypeScript関数）

```typescript
// 関数ベースによる条件記述例
condition: (ctx: EvaluationContext) => boolean
```

**利点:**
- 型安全性の確保
- デバッグが容易（ブレークポイント設定可能）
- IDE支援（補完、エラー検出）
- テストしやすい
- 通常のコードとして読める

**欠点:**
- ポリシーの外部化が困難
- 非プログラマーには難しい
- 実行時の動的変更が困難

## 決定

**関数ベース（オプション3）を採用**

学習用実装として、以下の型定義を採用します：

```typescript
type PolicyRule = {
  id: string
  description?: string
  effect: 'permit' | 'deny'
  condition: (context: EvaluationContext) => boolean
}
```

### 採用理由

#### 1. 学習効果の最大化

- **デバッグ容易性**: ブレークポイントを設定して条件評価をステップ実行可能
- **即座の型チェック**: TypeScriptにより実装ミスを即座に検出
- **IDE支援**: 完全な補完機能により学習者の負担を軽減

#### 2. 型安全性による品質向上

```typescript
// コンパイル時に型エラーとして検出される例
condition: (ctx) => {
  // タイポは即座にエラーになる
  return ctx.subject.departmnt === ctx.resource.department  // Error!
}
```

#### 3. テスト駆動学習の支援

```typescript
// 条件ロジックの単体テストが容易
const testContext: EvaluationContext = {
  subject: { department: 'engineering', clearanceLevel: 3 },
  resource: { department: 'engineering', classificationLevel: 2 },
  // ...
}

expect(policy.condition(testContext)).toBe(true)
```

#### 4. 段階的学習への対応

- 単純な条件から複雑な条件まで自然に記述可能
- 関数の組み合わせによる再利用性
- リファクタリングによる段階的改善

## 結果

### 利点

1. **学習体験の向上**
   - デバッガーによる動的な理解
   - 型安全性による早期エラー発見
   - IDE支援による実装支援

2. **実装品質の向上**
   - コンパイル時型チェック
   - テスタビリティの確保
   - リファクタリング安全性

3. **ABACの本質理解**
   - 属性評価ロジックの明示的な記述
   - 複合条件の組み合わせパターンの学習
   - 動的評価の仕組みの理解

### トレードオフ

1. **外部化の困難さ**
   - ポリシーをコード外に定義することが困難
   - 実行時の動的変更が制限される

2. **非プログラマーへの敷居**
   - TypeScript知識が前提となる
   - 関数記述に慣れが必要

### 今後の課題

1. **発展的学習への対応**
   - より高度なポリシー記述パターンの提供
   - 再利用可能な条件ライブラリの整備

2. **実システムへの移行**
   - JSON形式やDSLへの変換手法の学習
   - 外部化されたポリシーシステムとの比較学習

この決定により、学習者はABACの核心概念である「属性の動的評価」を、最も直接的で理解しやすい形で体験できます。