# ADR-002: 探索アルゴリズム - BFSと深度制限

## ステータス
- **日付**: 2025-08-14
- **状態**: 承認
- **決定者**: プロジェクトチーム

## コンテキスト

ReBACでは関係性グラフを探索して権限を導出する。効率的で予測可能な探索アルゴリズムと、無限ループを防ぐ仕組みが必要。

## 検討したオプション

### 1. 探索アルゴリズム

#### オプション1: 幅優先探索（BFS）
```typescript
function checkRelationBFS(subject: EntityId, relation: RelationType, object: EntityId): RelationPath | null
```
- 利点：最短パスを発見、循環検出が容易、レベル制限が簡単
- 欠点：メモリ使用量が多い（キューを使用）

#### オプション2: 深さ優先探索（DFS）
```typescript
function checkRelationDFS(subject: EntityId, relation: RelationType, object: EntityId): RelationPath | null
```
- 利点：メモリ効率的（スタックを使用）
- 欠点：最短パスを保証しない、深い再帰の可能性

### 2. 深度制限

#### オプション1: 無制限探索
- 利点：すべての可能な関係を発見
- 欠点：性能問題、無限ループのリスク

#### オプション2: 固定深さ制限
```typescript
const MAX_DEPTH = 3  // 3ホップまで
```
- 利点：性能が予測可能、無限ループ防止
- 欠点：正当な深い関係を見逃す可能性

#### オプション3: 設定可能な深度制限
```typescript
interface ReBACConfig {
  maxDepth: number  // デフォルト: 3、調整可能
}
```
- 利点：柔軟性と安全性のバランス
- 欠点：適切な値の設定が必要

## 決定

**探索アルゴリズム**: BFSを採用
- 権限チェックでは最短の関係パスが重要
- デバッグ時に関係の「距離」が分かりやすい
- 業界標準（Google Zanzibar、SpiceDB等）と一致

**深度制限**: 設定可能な深度制限を採用（デフォルト: 3）
- 段階的な学習が可能（1→2→3-5ホップ）
- 実用的な組織構造をカバー
- 性能と柔軟性のバランス

### 循環参照の対策
- 訪問済みノードをSetで管理
- BFSの特性により自然に循環を回避

## 結果

### 利点
- 最短パスの保証により権限の根拠が明確
- 予測可能な性能特性
- 実システムへの適用が容易

### トレードオフ
- メモリ使用量はDFSより多い
- 深い組織構造では深度制限の調整が必要

### 今後の課題
- 双方向探索による最適化
- キャッシュ戦略の検討
- 並列探索の実装